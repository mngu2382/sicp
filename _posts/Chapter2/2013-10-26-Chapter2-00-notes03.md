---
layout: post
title: 2.3 Symbolic Data
categories: chapter2
mathjax: true
---

All the compound data objects we have used so far were constructed
ultimately from numbers. In this section we extend the
representational capability of our lanaguage by introducing the
ability to work with arbitrary symbols as data.

## Quotation
If we can form compound data using symbols, we can have lists such as

    (a b c d)
    (23 45 17)
    (((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))

Lists containing symbols can look just like the expressions of our
language:

{% highlight scheme %}
(* (+ 23 45) (+ x 9))
(define (fact n) (if (= n 1) 1 (* n (fact (- n 1)))))
{% endhighlight %}

In order to manipulate symbols we need a new element in our language:
the ability to _quote_ a data object. Suppose we want to construct the
list `(a b)`. We can't accomplish this with `(list a b)`, because this
expression constructs a list of the _values_ of `a` and `b` rather
than the symbols themselves. This issue is well known in the context
of natural languages, where words and sentences may be regarded either
as sematic entities or as character strings (syntactic entities). The
common practice in natural languages is to use quotation marks to
indicate that a word or a sentence is to be treated literally as a
string of characters. For instance, the first letter of "John" is
clearly "J". If we tell sombody "say your name aloud", we expect to
hear that person's name. However, if we tell somebody "say 'your name'
alound", we expect to hear words "your name".

\[Allowing quotation in a language wreaks havoc with the ability to
reason about the language in simple terms, because ti destroys the
notion that equals can be substituted for equals. For example, three
is one plus two, but the word "three" is not the phrase "one plus two".
Quotation is powerful because it gives us a way to build expressions
that manipulate other expressions. But allowing statements in a
language that talk about other statements in that language makes it
very difficult to maintatin any coherent princple of what "equals can
be substituted for equals" should mean. For example, if we know that
the evening star is the morning star, the from the statement "the
evening star is Venus" we can deduce "the morning star is Venus".
However, given that "John knows that the evening star is Venus" we
cannot infer that "John knows that the morning star is Venus".\]

We can follow this same practice to identify list and symbols that are
to be treated as data objects rather than as expressions to be
evaluated. However, our format for quoting differs from that of
natural languages in that we place a quotation mark (traditionally,
that single quote symbol, `'`) only at the beginning of the object to
be quoted. We can get away with this in Scheme syntax because we rely
on blanks and parentheses to delimit objects. Thus, the meaning of the
single quote character is to quote the next object.

Now we can distinguish between symbols and their values:

{% highlight scheme %}
(define a 1)
(define b 2)
(list a b)
; (1 2)

(list 'a 'b)
; (a b)

(list 'a b)
; (a 2)
{% endhighlight %}

Quotation also allows us to type in compound objects, using the
conventional printed representation for lists:

{% highlight scheme %}
(car '(a b c))
; a

(cdr '(a b c))
; (b c)
{% endhighlight %}

In keeping with this, we can obtain the empty list by evaluating `'()`.

One additional primitive used in manipulating symbols is `eq?`, which
takes two symbols as arguments and tests whether they are the same.
Using `eq?`, we can implement a useful procedure called `memq`. This
takes two arguments, a symbol and a list. If the symbol is not
contained in the list (i.e., is not `eq?` to any item in the list),
then `memq` returns false. Otherwise, it returns the sublist of the
list beginning with the first occurrence of the symbol:

{% highlight scheme %}
(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))
{% endhighlight %}

For example, the value of

{% highlight scheme %}
(memq 'apple '(pear banana prune))
{% endhighlight %}

is false, whereas the value of

{% highlight scheme %}
(memq 'apple `(x (apple sauce) y apple pear))
{% endhighlight %}

is `(apple pear)`.

## Example: Symbolic Differentiation

As an illustration of symbol manipulation and a further illustration
of data abstraction, consider the design of a procedure that performs
symbolic differentiation of algebraic expressions. We would like the
procedure to take as arguments an algebraic expression and a variable
and to return the derivative of the expression with respect to the
variable.

In developing the symbolic-differentiation program, we will follow the
same strategy of data abdtraction that we followed in developing the
rational number system. That is, we will first define a
differentiation algorithm that operates on abstract objects such as
"sums", "products", and "variables" without worrying about how these
are to ve represented. Only afterward will we address the
representation problem.

### The differentiation program with abstract data

In order to keep things simple, we will consider a very simple
symbolic-differentiation program that handles expressions that are
built up using only the operations of addition and multiplication with
two arguments. Differentiation of any such expression can be carried
out by applying the following reduction rules:

$$
\frac{dc}{dx} = 0
$$

for $c$ a constant or a variable different from $x$,

$$
\begin{align}
\frac{dx}{dx} &= 1,\\\\
\frac{d(u + v)}{dx} &= \frac{du}{dx} + \frac{dv}{dx},\\\\
\frac{d(uv)}{dx} &= u\frac{dv}{dx} + v\frac{du}{dx}.
\end{align}
$$

Observe that the latter two are recursive in nature. That is, to
obtain the serivative of a sum we first find the derivative of the
terms and add them. Each of the terms may in turn be an expression
that needs to be decomposed. Decomposition into smaller pieces will
eventually produce pieces that are either contants or variables, whose
derivatives wull be either 0 or 1.

To embody these rules in a procedure we indulge in a little wishful
thinking, as we did in designing the rational number implementation.
If we had a means for representing algerbraic expressions, we should
be able to tell whether an expression is a sum, a product, a constant,
or a variable. We should be able to extract the parts of an expression.
For a sum, for example we want to be able to extract the addend (first
term) and the augend (second term). We should also be able to
construct expressions from parts. Let us assume that we already have
procedures to implement the following selectors, constructors and
predicates:

{% highlight scheme %}
(variable? e)          ; is e a variable?
(same-variable? v1 v2) ; are v1 and v2 the same variable?
(sum? e)               ; is e a sum?
(addend e)             ; addend of the sum e
(augend e)             ; augend of the sum e
(make-sum a1 a2)       ; construct the sum of a1 and a2
(product? e)           ; is e a product?
(multiplier e)         ; multiplier of the product e
(multiplicand e)       ; multiplicand of the product e
(make-product m1 m2)   ; construct the product of m1 and m2
{% endhighlight %}

Using these, and the primitive predicate `number?`, which identifies
numbers, we can express the differentiation rules as the following
procedure:

{% highlight scheme %}
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
         (error "unknown expression type - DERIV" exp))))
{% endhighlight %}

This `deriv` procedure incorporates the complete differentiation
algorithm. Since it is expressed in terms of abstract data, it will
work no matter how we choose to represent algebraic expressioins, as
long as we design a proper set of selectors and constructors, This is
the issue we must address next.

### Representing algebraic expressions

We can imagine many ways to use list structure to represent algebraic
expressions. For example, we could use lists of symbols that mirror
the usual algebraic notation, representing $ax + b$ as the list
`(a * x + b)`. However, one especially straightforward choise is to
use that same parenthesized prefix notation that Lisp uses for
combinations; that is, to represent $ax + b$ as `(+ (* a x) b)`. Then
our data representation for the differentiation problem is as follows:

- The variables are symbols. They are identified by the primitive
  predicate `symbol?`

      (define (variable? x) (symbol? x))

- Two variables are the same if the symbols representing them are
  `eq/`:

      (define (same-variable? v1 v2)
        (and (variable? v1) (variable? v2) (eq? v1 v2)))

- Sums and products are constructed as lists:

      (define (make-sum a1 a2) (list '+ a1 a2))
      (define (make-product m1 m2) (list '* m1 m2))

- A sum is a list whose first element is the symbol `+`:

      (define (sum? x)
        (and (pair? x) (eq? (car x) '+)))

- The addend is the second item of the sum list:

      (define (addend s) (cadr s))

- The augend is the third item if the sum list:

      (define (augend s) (caddr s))

- A product is a list whose first element is the symbol `*`:

      (define (product? x)
        (and (pair? x) (eq? (car x) '*)))

- The multipler is the second list of the product list:

      (define (multiplier p) (cadr p))

- The multiplicand is the third item of the product list:

      (define (multiplicand p) (caddr p))

Thus, we need only combine these with the algorithm as embodied by
`deriv` in order to have a working symbolic-differentiation program.
Let us look at some examples of its behaviour:

{% highlight scheme %}
(deriv '(+ x 3) 'x)
;(+ 1 0)

(deriv '(* x y) 'x)
;(+ (* x 0) (* 1 y))

(deriv '(* (* x y) (+ x 3)) 'x)
;(+ (* (* x y) (+ 1 0))
;   (* (+ (* x 0) (* 1 y))
;      (+ x 3)))
{% endhighlight %}

The program produces answers that are correct; however, they are
umsimplified. We would like the program to know that $x\cdot 0=1$,
$1\cdot y=y$, and $0 + y=y$. The answer for the second example should
have been simply `y`. As the thrid example shows, this becomes a
serious issue when the expressions are complex.

Our difficulty is much like the onw we encountered with the rational
number implementation: we haven't reduced answers to simplist form. To
accomplish the rational number reduction, we needed to change only the
constructors and the selectors of the implementation. We can adopt a
similiar strategy here. We won't change `deriv` at all. Instead, we
will change `make-sum` so that if both summands are numbers, `make-sum`
will add them and return their sum. Also, if one of the summands is 0,
then `make-sum` will return the other summand.

{% highlight scheme %}
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
{% endhighlight %}

This uses the procedure `=number?`, which checks whether an expression
is equal to a given number:

{% highlight scheme %}
(define (=number? exp num)
  (and (number? exp) (= exp num)))
{% endhighlight %}

Similary, we will change `make-product`:

{% highlight scheme %}
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
{% endhighlight %}

Here is how this version works on our three examples:

{% highlight scheme %}
(deriv '(+ x 3) 'x)
; 1

(deriv '(* x y) 'x)
; y

(deriv '(* (* x y) (+ x 3)) 'x)
; (+ (* x y) (* y (+ x 3)))
{% endhighlight %}

Although this is quite an improvement, the third example shows that
there is still a long way to go before we get a program that puts
expressions into a form that we might agree is "simplest". The problem
of algebraic simplification is complex because, among other reasons, a
form that may be simplest for one purpose may not be for another.
