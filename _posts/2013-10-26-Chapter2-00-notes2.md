---
layout: post
title: 2.2 Hierarchical Data and the Closure Property
categories: chapter2
---

As we have seen, pairs provide a primitive "glue" that we can use to
construct compounf data objects. The figure below shows a standard way
to visualize a pair -- in this case, the pair formed by `(cons 1 2)`.

![Pair (cons 1 2)]({{ site.baseurl }}/images/Fig2-02.png "Pair (cons 1 2)")

In this representation, which is called __box-pointer notation__, each
object is shown as a __pointer__ to a box. The box for a primitive
object contains a representation of the object. The box for a pair is
actually a double box, the left part containing (a pointer to) the
`car` of the pair and the right part containing the `cdr`.

We have already seen that `cons` can be used to combine not only
numbers but pairs as well. As a consequence, pairs provide a universal
building block from which we can construct all sorts of data
structures. The figures below show two ways to use pairs to combine
the numbers 1, 2, 3, and 4.

![Cons of 1, 2, 3, 4.]({{ site.baseurl }}/images/Fig2-03.png "Cons of 1, 2, 3, 4.")

The ability to create pairs whose elements are pairs is the essence of
list structure;s importance as a representational tool. We refer to
this as the __closure property__ of `cons`. In general, an operation
for combining data objects satisfies the closure property if the
result of combining things with that operation can themselves be
combined using the same operation. Closure is the key to power in any
means of combination becuase it permits us to create __hierarchical__
structures -- structures made up of parts, which themselves are made
up of parts, and so on.

#### Representing Sequences
A __sequence__ is an ordered collection of data objects. A
straightforward representation of sequences using pairs is illustrated
below, where the sequence 1, 2, 3, 4 is represented as a chain of
pairs. The `car` of each pair is the corresponding item in the chain,
and the `cdr` of the pair is the next pair in the chain. The `cdr` of
the final pair signals the end of the sequence by pointing to a
distinguished value that is not a pair, represented in box-and-pointer
diagrams as a diagonal line and in programs as the value of the
variable `nil` (or rather `'()` in mit-scheme). The entire sequence is
constructed by nested `cons` operations:

{% highlight scheme %}
(define nil '())

(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
{% endhighlight %}

![Sequence of 1, 2, 3, 4]({{ site.baseurl }}/images/Fig2-04.png "List of 1, 2, 3, 4.")

Such a sequence of pairs, formed by nested `cons`es, is called a
__list__, and Scheme provides a primitive `list` to help construct
lists. \[In this book, we use _list_ to mean a chain of pairs
terminated bu the end-of-list marker. In contrast, the term _list
structure_ refers to any data structure made out of pairs, not just to
lists.\]

In general,

{% highlight scheme %}
(list <a1> <a2> ... <an>)
{% endhighlight %}

is equivalent to

{% highlight scheme %}
(cons <a1>
      (cons <a2>
            (cons ...
                  (cons <an> nil) ...)))
{% endhighlight %}

Lisp systems conventionally prints lists by printing the sequence of
elements, encolsed in parentheses, for example `(1 2 3 4)`.

We can think of `car` as selecting the first item in the list, and of
`cdr` as selecting the sublist consisting of all but the first item.
Nested applications of `car` and `cdr` can be used to etract the
second, third, and subsequent items in the list. The constructor `cons`
makes a list like the original one, but with an additional item at the
beginning.

##### List operations
The use of pairs to represent sequences of elements as list is
accompanied by conventional programming techniques for manipulating
lists bu successively "cdring down" the list. For example, the
procedure `list-ref` takes as arguments a list and a number `n` and
returns the `n`th item of the list. It is customary to number the
elements of the list beginning with 0. The method for computing
`list-ref` is the following: For `n = 0`, `list-ref` should return the
`car` of the list. Otherwise, list-ref should return the `(n-1)`th
item of the `cdr`list.

{% highlight scheme %}
(define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))))
{% endhighlight %}

Often we `cdr` down the whole list. To aid in this, Scheme includes a
primitive predicate `null?`, which tests whether its arguments is the
empty list. The procedure `length`, which returns the number of items
in a list, illustrates this typical pattern of use:

{% highlight scheme %}
(define (length items)
    (if (null? items)
        0
        (+ 1 (length (cdr items)))))
{% endhighlight %}

Another conventional programming technique is to "cons up" an answer
list while cdring down a list, as in the procedure `append`, which
takes two lists as arguments and combines their elements to make a new
list:

{% highlight scheme %}
(define (append list1 list2)
    (if (null? list1)
        list2
        (cons (car list1)
              (append (cdr list1) list2))))
{% endhighlight %}
