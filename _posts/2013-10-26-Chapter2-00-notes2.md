---
layout: post
title: 2.2 Hierarchical Data and the Closure Property
categories: chapter2
---

As we have seen, pairs provide a primitive "glue" that we can use to
construct compounf data objects. The figure below shows a standard way
to visualize a pair -- in this case, the pair formed by `(cons 1 2)`.

![Pair (cons 1 2)]({{ site.baseurl }}/images/Fig2-02.png "Pair (cons 1 2)")

In this representation, which is called __box-pointer notation__, each
object is shown as a __pointer__ to a box. The box for a primitive
object contains a representation of the object. The box for a pair is
actually a double box, the left part containing (a pointer to) the
`car` of the pair and the right part containing the `cdr`.

We have already seen that `cons` can be used to combine not only
numbers but pairs as well. As a consequence, pairs provide a universal
building block from which we can construct all sorts of data
structures. The figures below show two ways to use pairs to combine
the numbers 1, 2, 3, and 4.

![Cons of 1, 2, 3, 4.]({{ site.baseurl }}/images/Fig2-03.png "Cons of 1, 2, 3, 4.")

The ability to create pairs whose elements are pairs is the essence of
list structure;s importance as a representational tool. We refer to
this as the __closure property__ of `cons`. In general, an operation
for combining data objects satisfies the closure property if the
result of combining things with that operation can themselves be
combined using the same operation. Closure is the key to power in any
means of combination becuase it permits us to create __hierarchical__
structures -- structures made up of parts, which themselves are made
up of parts, and so on.

#### Representing Sequences
A __sequence__ is an ordered collection of data objects. A
straightforward representation of sequences using pairs is illustrated
below, where the sequence 1, 2, 3, 4 is represented as a chain of
pairs. The `car` of each pair is the corresponding item in the chain,
and the `cdr` of the pair is the next pair in the chain. The `cdr` of
the final pair signals the end of the sequence by pointing to a
distinguished value that is not a pair, represented in box-and-pointer
diagrams as a diagonal line and in programs as the value of the
variable `nil` (or rather `'()` in mit-scheme). The entire sequence is
constructed by nested `cons` operations:

{% highlight scheme %}
(define nil '())

(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
{% endhighlight %}

![Sequence of 1, 2, 3, 4]({{ site.baseurl }}/images/Fig2-04.png "List of 1, 2, 3, 4.")

Such a sequence of pairs, formed by nested `cons`es, is called a
__list__, and Scheme provides a primitive `list` to help construct
lists. \[In this book, we use _list_ to mean a chain of pairs
terminated bu the end-of-list marker. In contrast, the term _list
structure_ refers to any data structure made out of pairs, not just to
lists.\]

In general,

{% highlight scheme %}
(list <a1> <a2> ... <an>)
{% endhighlight %}

is equivalent to

{% highlight scheme %}
(cons <a1>
      (cons <a2>
            (cons ...
                  (cons <an> nil) ...)))
{% endhighlight %}

Lisp systems conventionally prints lists by printing the sequence of
elements, encolsed in parentheses, for example `(1 2 3 4)`.

We can think of `car` as selecting the first item in the list, and of
`cdr` as selecting the sublist consisting of all but the first item.
Nested applications of `car` and `cdr` can be used to etract the
second, third, and subsequent items in the list. The constructor `cons`
makes a list like the original one, but with an additional item at the
beginning.

##### List operations
The use of pairs to represent sequences of elements as list is
accompanied by conventional programming techniques for manipulating
lists bu successively "cdring down" the list. For example, the
procedure `list-ref` takes as arguments a list and a number `n` and
returns the `n`th item of the list. It is customary to number the
elements of the list beginning with 0. The method for computing
`list-ref` is the following: For `n = 0`, `list-ref` should return the
`car` of the list. Otherwise, list-ref should return the `(n-1)`th
item of the `cdr`list.

{% highlight scheme %}
(define (list-ref items n)
    (if (= n 0)
        (car items)
        (list-ref (cdr items) (- n 1))))
{% endhighlight %}

Often we `cdr` down the whole list. To aid in this, Scheme includes a
primitive predicate `null?`, which tests whether its arguments is the
empty list. The procedure `length`, which returns the number of items
in a list, illustrates this typical pattern of use:

{% highlight scheme %}
(define (length items)
    (if (null? items)
        0
        (+ 1 (length (cdr items)))))
{% endhighlight %}

Another conventional programming technique is to "cons up" an answer
list while cdring down a list, as in the procedure `append`, which
takes two lists as arguments and combines their elements to make a new
list:

{% highlight scheme %}
(define (append list1 list2)
    (if (null? list1)
        list2
        (cons (car list1)
              (append (cdr list1) list2))))
{% endhighlight %}

#### Mapping over lists
One extremely useful operation is to apply some transformation tp
each element in a list and generate the list of results. For instance,
the following procedure scales each number in a list by a given
factor:

{% highlight scheme %}
(define (scale-list items factor)
    (if (null? items)
        '()
        (cons (* (car items) factor)
              (scale-list (cdr items factor)))))
{% endhighlight %}

We can abstract this general idea and capture it as a common pattern
expressed as a high-order procedure. The higher-order procedure here
is called `map`. It take as arguments a procedure of one argument and
a list, and returns a list of the results produced by applying the
procedure to each element in the list:

{% highlight scheme %}
(define (map proc items)
    (if (null? items)
        '()
        (cons (proc (car items))
              (map proc (cdr items)))))
{% endhighlight %}

Now we can give a new definition of `scale-list` in terms of `map`:

{% highlight scheme %}
(define (scale-list items factor)
    (map (lambda (x) (* x factor))
         items))
{% endhighlight %}

Scheme standardly provides a `map` procedure that is more general: it
takes as arguments a procedure of `n` arguments together with `n`
lists and applies the procedure with all the first elements of the
lists as arguments, then all the second elements, and so on, returning
a list of the results. For example:

{% highlight scheme %}
(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
; (741 852 963)
{% endhighlight %}

The procedure `map` is an important construct, not only because it
captures a common pattern, but because it establishes a higher-level
of abstraction in dealing with lists. In the original definition of
`scale-list`, the recursive structure of the program draws attention
to the element-by-element processing of the list. Defining `scale-list`
in terms of `map` suppresses that level of detail and emphasizes that
scaling transforms a list of elements to a list of results. The
difference between the two definitions is not that the computer is
performing a different process (it isn't) but that we think about the
process differently.

### Hierarchical structures
The represenation of sequences in terms of lists generalizes naturally
to represent sequences whose elements may themselves be sequences. For
example, we can regard the object `((1 2) 3 4)` constructed by

{% highlight scheme %}
(cons (list 1 2 ) (list 3 4))
{% endhighlight %}

as a list of three items, the first if which is itself a list, `(1 2)`.
Indeed, this is suggested by the form in which  the result is printed
by the interpreter. The following figure shows the representation of
this structure in terms of pairs.

![Structure formed by (cons (list 1 2) (list 3 4))]({{ site.baseurl }}/images/Fig2-05.png "Structure formed by (cons (list 1 2) (list 3 4))")

Another way to think of sequences whose elements are sequences is as
_trees_. The elements of the sequences are the branches of the tree,
and elements that are themselves sequences are subtrees. The following
figure shows the structure viewed as a tree.

![The list structure (cons (list 1 2) (list 3 4)) viewed as a tree]({{ site.baseurl }}/images/Fig2-06.png "The list structure (cons (list 1 2) (list 3 4)) viewed as a tree")
