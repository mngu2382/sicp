---
layout: post
title: 1.2 Procedures and the Processes They Generate
categories: chapter1
mathjax: true
---

A procedure is a pattern for the _local evolution_ of a computational
process. We wish to take a step back from the procedure and maybe say
something about the overall, or _global_, behaviour of the process that
is specified by the procedure.

Some of the global behaviours that we look at in this section are the
common "shapes" generated by procedures and the rates of growth in
time and space of procedures.

#### Linear Recursion and Iteration
Consider the factorial function:

$$
n! = n(n-1)(n-2)\ldots 3\cdot 2\cdot 1
$$

Two possible ways of calculating the function with illustrations of how
the procedures evolved:
{% highlight scheme %}
; first method
(define (factorial n)
    (if (= n 1)
        1
        (* n (factorial (- n 1)))))

(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720

; second method
(define (factorial n)
    (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))

(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 4 6)
(fact-iter 24 5 6)
(fact-iter 120 6 6)
(fact-iter 720 7 6)
720
{% endhighlight %}

Consider the first process: the substitution model reveals a wedge
shape as the expression expands and contracts. The expansion occurs as
the process builds up a chain of _deferred operations_, contraction
occurs as the operations are performed. This type of process,
characterised by a chain of deferred operations, is called a
__recursive process__. Carrying out this process requires that the
interpreter keep track of the operations to be performed later on. In
this case, the computation of factorial creates a chain of deferred
operations of length proportional to the input, so we called this a
_linear recursive process_.

The second process revels a rectangular shape: at each step, all we
need to keep track of are the current values of the variables in
`fact-iter`. This type of process is called an __iterative process__.
An iterative process is one whose state can be summarised by a fixed
number of _state variables_, together with rules which describe how the
state variables should be updated as the process moves from state to
state and conditions which specify how the process will terminate.
Again, the number of steps in the factorial procedure grows linearly
with the input, so we call it a _linear iterative process_.

Note that in talking about iteration and recursion, there is a
difference between a recursive _process_ and a recursive _procedure_.
When a procedure is descibed as recursive, we are referring to the
syntactic fact that the procedure refers to itself in its definition.
When a process is described as recursive, we are refering to the way
the process evolves through deferred operations. So, for example,
`fact-iter` is a recursive procedure but an iterative process.

#### Tree Recursion
__Tree recursion__ is another common pattern in computation. A typical
example of this pattern is produced by the following procedure for
generating the Fibonacci sequence:
{% highlight scheme %}
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
{% endhighlight %}
To compute `(fib 5)`, we compute `(fib 4)` and `(fib 3)`. To compute
`(fib 4)`, we compute `(fib 3)` and `(fib 2)`. That is the process
branches into two computations at each level (except at the bottom)
reflecting the fact that the `fib` procedures calls itself twice each
time it is invoked.

![Fibonacci tree recursion]({{ site.baseurl }}/images/Fig1-05.png "Fibonnaci tree recursion")

The process uses a number of steps that grows exponentially with the
input. While the space required grows only linearly with the input
as we need keep track only of  which nodes are above us in the tree at
any point in the computation. In general the number
of steps required by a tree-recursive process wil be proportional to
the number of nodes in the tree, while the space required will be
proportional to the maxium depth of the tree. _\[TODO: points about
space requirements of recursive trees are not clear to me.\]_

The Fibonacci sequence can also be formulated as an iterative process.
The idea is to use a pair of numbers, initialised to
$\mathrm{Fib}(1)=1$ and $\mathrm{Fib}(0)=0$, and to repeatly apply the
simultaneous transformations

$$
\begin{align}
a &\leftarrow a + b\\\\
b &\leftarrow a
\end{align}
$$

Thus we can compute Fibonacci numbers using the preocedure
{% highlight scheme %}
(define (fib n)
  (fib-iter 1 0 n))
  
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
{% endhighlight %}
This scond mehtod for computing $\mathrm{Fib}(n)$ is a linear iteration.

##### Example: Counting change
