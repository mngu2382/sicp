---
layout: post
title: 1.1 The Elements of Programming
categories: chapter1
---

This section introduces the basic language features of __Scheme__.

#### Expressions and Combinations

An __expression__ is a unit of the language: a combination of
syntactically correct characters and something that can be evaluated
by an interpreter.

A __combination__ is a list of expressions, surround by parentheses,
denoting a procedure application. The first element in the list is the
__operator__. Subsequent expression are the __operands__. This method
of expressing operations, with the operator first followed by the
operands, is called __prefix notation__.

{% highlight scheme %}
(<operator> <operand1> <operand2> ...)
{% endhighlight %}

The value of a combination is the obtained by the application of
`operator` (a _procedure_) to the __arguments__ (which are _values_)
given by the evaluation of the `operand`s (which are _expressions_).

#### Defining Variables and Procedures

We can define variables using `define`, 

{% highlight scheme %}
(define <varName> <varValue>)
{% endhighlight %}
Note that the `define` procedure does not follow the steps for
evaluating combinations described in the paragraph above:
> evaluating `(define x 3)` does not apply define to two arguments,
> one of which is the value of the symbol `x` and the other of which
> is 3, since the purpose of the define is precisely to associate `x`
> with a value. (That is, `(define x 3)` is not a combination.)

Procedures that do not follow the general evaluation rule are called
__special forms__. Each special form has its own evaluation rule.

The `define` procedure can be used to define procedures as well, these
are called __compound procedures__:

{% highlight scheme %}
(define (<name> <formal params>) <body>)
{% endhighlight %}

For example:

{% highlight scheme %}
(define (square x) (* x x))
(define (sum-of-squares x y) (+ (square x) (square y)))
{% endhighlight %}

#### The Substitution Model

The __substitution model__ is used to help us think about how compound
procedures are evaluated:
> To apply a compound procedure to arguments, evaluate the body of the
> procedure with each formal parameter replaced by the corresponding
> argument.

Using the substitution model there are two different way in which to
evaluate a compound procedure: 

* __applicative order__ evaluates the operands before substitutes them
to the definition of the compound procedure;
* __normal order__ substitutes the unevaluated operands to the
definition of the compound procedure and only evaluated operands as
their values are needed.

An example using the `square` compound procedure:

###### Applicative Order

{% highlight scheme %}
(square (+ 1 5))
(square 6)
(* 6 6)
{% endhighlight %}

###### Normal Order

{% highlight scheme %}
(square (+ 1 5))
(* (+ 1 5) (+ 1 5))
(* 6 6)
{% endhighlight %}

Applicative order and normal order evaluation will produce that same
value for procedures that can be interpreted using the substitution
model.

Scheme uses applicative order evaluation. This is mainly due to its
advantage over normal order for procedures that can't be interpreted
using the substitution model. Normal order evaluation, of course, has
its advantages which will be explored in later sections.

#### Conditional Expressions

A __case analysis__ can be performed using the `cond` special form

{% highlight scheme %}
(cond (<pred1> <exp1>)
      (<pred2> <exp2>)
      ...
      (<predN> <expN>))
{% endhighlight %}
where `pred` are predicates that evaluate to `#t`/`#f` and the
expressions `exp` are the possible values of `cond`. Predicates are
successively evaluated, the expression associated with the first true
predicate is the value returned by `cond`, subsequent predicates and
expressions are not evaluated. If none of the predicates are true an
__unspecified value__ is returned.

Note that in cases where `#t`/`#f` is expected any value not `#f` is
considered as `#t` (that is, `0` and `""` are also "true").

The `cond` expression also supports a catch-all case: the keyword
`else` can be used in place of the last predicate, its associated
value is returned in the case where all predicates are false. 

{% highlight scheme %}
(cond (<pred1> <exp1>)
      ...
      (else <expN>))
{% endhighlight %}

The `if` special form can be used when there are only two cases:

{% highlight scheme %}
(if <pred> <consequent> <alternative>)
{% endhighlight %}

#### Logical Expressions

There are __primitive predicates__ such as `<`, `=` and `>`.

There are __logical composition operations__:

{% highlight scheme %}
(and <pred1> ... <predN>)
{% endhighlight %}
the predicates `pred` are evalutated from left to right, if a
predicate is false subsequent predicates are not evalutated and the
`and` expression is false. If all predicates are true then the `and`
expression is true

{% highlight scheme %}
(or <pred1> ... <predN>)
{% endhighlight %}
similar to `and` -- the predicates `pred` are evaluated until the
first true in which case the `or` expression is true. If all
predicates are false then the `or` expression is false

{% highlight scheme %}
(not <pred>)
{% endhighlight %}
the negation of `pred`

#### Example: Square Roots by Newton's Method

> whenever we have a guess y for the value of a square root of a
> number x, we can alway produce a better guess by averaging y
> with x/y

{% highlight scheme %}
(define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                   x)))

(define (improve guess x)
    (average guess (/ x guess)))

(define (average x y)
    (/ (+ x y) 2))

(define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))

(define (sqrt x)
    (sqrt-iter 1.0 x))
{% endhighlight %}

#### Procedures as Black Box Abstractions

In the example above, the process of finding the square root of a
number has been broken down into sub-tasks performed by separate
procedures. Each procedure is completely self-contained in performing
its specified task.

When a procedure is self-contained so that knowledge of its
implementation is not curcial to its use, it can be readily used as a
module in the definitions of other procedures, that is, the use can
treat it as a box block or __procedural abstraction__.

For example, in the `good-enough?` procedure, whether `square` is
defined in terms of mulitplcation or exponentials and logarithms
ought not be of concern to the user

{% highlight scheme %}
(define (square x) (* x x))

(define (square x)
    (exp (double (log x))))
(define (double x) (+ x x))
{% endhighlight %}

It should also not matter, in the second version of `square`, that `x`
is used as the formal parameter in both `square` and `double`. This
potential mix up is avoided by making formal parameters local to their
procedures.

##### Local Variables
One detail of a procedure's implementation that should not matter to
the user is the implementer's choice of names for the procedure's
formal parameters. That is, the following pair should be
indistinguishable:

{% highlight scheme %}
(define (square (x) (* x x))

(define (square (y) (* y y))
{% endhighlight %}


