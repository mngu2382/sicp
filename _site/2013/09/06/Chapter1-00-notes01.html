<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>SICP: Chapter 1: The Elements of Programming</title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="http://mngu2382.github.io/sicp/css/main.css">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="http://mngu2382.github.io/sicp/images/tmp.png"/>
    
    
  </head>
  
  <body>
    <header id="banner">
      <h1><a href="http://mngu2382.github.io">:testSite <strong>a work in progress</strong></a></h1>
      <nav><ul>
        <li><a href="http://mngu2382.github.io/sicp/index.html">A SICP Walkthrough</a></li>
      </ul></nav>
    </header>

    <section>
      <h2>Chapter 1: The Elements of Programming</h2>

<p>This section introduces the basic language features of <strong>Scheme</strong>.</p>

<h4>Expressions and Combinations</h4>

<p>An <strong>expression</strong> is a unit of the language: a combination of
syntactically correct characters and something that can be evaluated
by an interpreter.</p>

<p>A <strong>combination</strong> is a list of expressions, surround by parentheses,
denoting a procedure application. The first element in the list is the
<strong>operator</strong>. Subsequent expression are the <strong>operands</strong>. This method
of expressing operations, with the operator first followed by the
operands, is called <strong>prefix notation</strong>.</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="nf">&lt;operator&gt;</span> <span class="nv">&lt;operand1&gt;</span> <span class="nv">&lt;operand2&gt;</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div>

<p>The value of a combination is the obtained by the application of
<code>operator</code> (a <em>procedure</em>) to the <strong>arguments</strong> (which are <em>values</em>)
given by the evaluation of the <code>operand</code>s (which are <em>expressions</em>).</p>

<h4>Defining Variables and Procedures</h4>

<p>We can define variables using <code>define</code>, </p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">&lt;varName&gt;</span> <span class="nv">&lt;varValue&gt;</span><span class="p">)</span>
</code></pre></div>

<p>Note that the <code>define</code> procedure does not follow the steps for
evaluating combinations described in the paragraph above:</p>

<blockquote>
<p>evaluating <code>(define x 3)</code> does not apply define to two arguments,
one of which is the value of the symbol <code>x</code> and the other of which
is 3, since the purpose of the define is precisely to associate <code>x</code>
with a value. (That is, <code>(define x 3)</code> is not a combination.)</p>
</blockquote>

<p>Procedures that do not follow the general evaluation rule are called
<strong>special forms</strong>. Each special form has its own evaluation rule.</p>

<p>The <code>define</code> procedure can be used to define procedures as well, these
are called <strong>compound procedures</strong>:</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">&lt;name&gt;</span> <span class="nv">&lt;formal</span> <span class="nv">params&gt;</span><span class="p">)</span> <span class="nv">&lt;body&gt;</span><span class="p">)</span>
</code></pre></div>

<p>For example:</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum-of-squares</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">y</span><span class="p">)))</span>
</code></pre></div>

<h4>The Substitution Model</h4>

<p>The <strong>substitution model</strong> is used to help us think about how compound
procedures are evaluated:</p>

<blockquote>
<p>To apply a compound procedure to arguments, evaluate the body of the
procedure with each formal parameter replaced by the corresponding
argument.</p>
</blockquote>

<p>Using the substitution model there are two different way in which to
evaluate a compound procedure: </p>

<ul>
<li><strong>applicative order</strong> evaluates the operands before substitutes them
to the definition of the compound procedure;</li>
<li><strong>normal order</strong> substitutes the unevaluated operands to the
definition of the compound procedure and only evaluated operands as
their values are needed.</li>
</ul>

<p>An example using the <code>square</code> compound procedure:</p>

<h6>Applicative Order</h6>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nf">square</span> <span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="nb">* </span><span class="mi">6</span> <span class="mi">6</span><span class="p">)</span>
</code></pre></div>

<h6>Normal Order</h6>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="nb">* </span><span class="mi">6</span> <span class="mi">6</span><span class="p">)</span>
</code></pre></div>

<p>Applicative order and normal order evaluation will produce that same
value for procedures that can be interpreted using the substitution
model.</p>

<p>Scheme uses applicative order evaluation. This is mainly due to its
advantage over normal order for procedures that can&#39;t be interpreted
using the substitution model. Normal order evaluation, of course, has
its advantages which will be explored in later sections.</p>

<h4>Conditional Expressions</h4>

<p>A <strong>case analysis</strong> can be performed using the <code>cond</code> special form</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="nf">&lt;pred1&gt;</span> <span class="nv">&lt;exp1&gt;</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">&lt;pred2&gt;</span> <span class="nv">&lt;exp2&gt;</span><span class="p">)</span>
      <span class="o">...</span>
      <span class="p">(</span><span class="nf">&lt;predN&gt;</span> <span class="nv">&lt;expN&gt;</span><span class="p">))</span>
</code></pre></div>

<p>where <code>pred</code> are predicates that evaluate to <code>#t</code>/<code>#f</code> and the
expressions <code>exp</code> are the possible values of <code>cond</code>. Predicates are
successively evaluated, the expression associated with the first true
predicate is the value returned by <code>cond</code>, subsequent predicates and
expressions are not evaluated. If none of the predicates are true an
<strong>unspecified value</strong> is returned.</p>

<p>Note that in cases where <code>#t</code>/<code>#f</code> is expected any value not <code>#f</code> is
considered as <code>#t</code> (that is, <code>0</code> and <code>&quot;&quot;</code> are also &quot;true&quot;).</p>

<p>The <code>cond</code> expression also supports a catch-all case: the keyword
<code>else</code> can be used in place of the last predicate, its associated
value is returned in the case where all predicates are false. </p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="nf">&lt;pred1&gt;</span> <span class="nv">&lt;exp1&gt;</span><span class="p">)</span>
      <span class="o">...</span>
      <span class="p">(</span><span class="k">else </span><span class="nv">&lt;expN&gt;</span><span class="p">))</span>
</code></pre></div>

<p>The <code>if</code> special form can be used when there are only two cases:</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">if </span><span class="nv">&lt;pred&gt;</span> <span class="nv">&lt;consequent&gt;</span> <span class="nv">&lt;alternative&gt;</span><span class="p">)</span>
</code></pre></div>

<h4>Logical Expressions</h4>

<p>There are <strong>primitive predicates</strong> such as <code>&lt;</code>, <code>=</code> and <code>&gt;</code>.</p>

<p>There are <strong>logical composition operations</strong>:</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">and </span><span class="nv">&lt;pred1&gt;</span> <span class="o">...</span> <span class="nv">&lt;predN&gt;</span><span class="p">)</span>
</code></pre></div>

<p>the predicates <code>pred</code> are evalutated from left to right, if a
predicate is false subsequent predicates are not evalutated and the
<code>and</code> expression is false. If all predicates are true then the <code>and</code>
expression is true</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">or </span><span class="nv">&lt;pred1&gt;</span> <span class="o">...</span> <span class="nv">&lt;predN&gt;</span><span class="p">)</span>
</code></pre></div>

<p>similar to <code>and</code> -- the predicates <code>pred</code> are evaluated until the
first true in which case the <code>or</code> expression is true. If all
predicates are false then the <code>or</code> expression is false</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="nb">not </span><span class="nv">&lt;pred&gt;</span><span class="p">)</span>
</code></pre></div>

<p>the negation of <code>pred</code></p>

<h4>Example: Square Roots by Newton&#39;s Method</h4>

<blockquote>
<p>whenever we have a guess y for the value of a square root of a
number x, we can alway produce a better guess by averaging y
with x/y</p>
</blockquote>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sqrt-iter</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
        <span class="nv">guess</span>
        <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
                   <span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">average</span> <span class="nv">guess</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">guess</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">average</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">abs </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">square</span> <span class="nv">guess</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="mf">0.001</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nb">sqrt </span><span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="mf">1.0</span> <span class="nv">x</span><span class="p">))</span>
</code></pre></div>

<h4>Procedures as Black Box Abstractions</h4>

<p>In the example above, the process of finding the square root of a
number has been broken down into sub-tasks performed by separate
procedures. Each procedure is completely self-contained in performing
its specified task.</p>

<p>When a procedure is self-contained so that knowledge of its
implementation is not curcial to its use, it can be readily used as a
module in the definitions of other procedures, that is, the use can
treat it as a box block or <strong>procedural abstraction</strong>.</p>

<p>For example, in the <code>good-enough?</code> procedure, whether <code>square</code> is
defined in terms of mulitplcation or exponentials and logarithms
ought not be of concern to the user</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">square</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">exp </span><span class="p">(</span><span class="nf">double</span> <span class="p">(</span><span class="nb">log </span><span class="nv">x</span><span class="p">))))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">double</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
</code></pre></div>

<p>It should also not matter, in the second version of <code>square</code>, that <code>x</code>
is used as the formal parameter in both <code>square</code> and <code>double</code>. This
potential mix up is avoided by making formal parameters local to their
procedures.</p>

<h5>Local Variables</h5>

<p>One detail of a procedure&#39;s implementation that should not matter to
the user is the implementer&#39;s choice of names for the procedure&#39;s
formal parameters. That is, the following pair should be
indistinguishable:</p>

<div class="highlight"><pre><code class="scheme"><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="nf">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">y</span> <span class="nv">y</span><span class="p">))</span>
</code></pre></div>


    </section>

    <aside>
      <h2>Contents</h2>
      <ul>
        
          
            <li><a href="http://mngu2382.github.io/sicp/jekyll/update/2013/09/04/welcome-to-jekyll.html">Welcome to Jekyll!</a></li>
          
        
          
            <li><a href="http://mngu2382.github.io/sicp/2013/09/06/Chapter1-00-notes01.html"><strong>Chapter 1: The Elements of Programming</strong></a></li>
          
        
          
            <li><a href="http://mngu2382.github.io/sicp/2013/09/06/Chapter1-00-notes02.html">Chapter 1: Notes 2</a></li>
          
        
          
            <li><a href="http://mngu2382.github.io/sicp/2013/09/06/Chapter1-01-exercise01.html">Chapter 1: Exerices 1.6 -- 1.8 </a></li>
          
        
          
            <li><a href="http://mngu2382.github.io/sicp/2013/09/06/Chapter1-01-exercise02.html">Chapter 1: Exerices 1.9 -- 1.10 </a></li>
          
        
          
            <li><a href="http://mngu2382.github.io/sicp/2013/09/06/Chapter1-01-exercise03.html">Chapter 1: Exerices 1.11 -- 1.13</a></li>
          
        
          
            <li><a href="http://mngu2382.github.io/sicp/2013/09/06/Chapter1-01-exercise04.html">Chapter 1: Exerices 1.14 -- 1.15</a></li>
          
        
          
            <li><a href="http://mngu2382.github.io/sicp/2013/09/06/Chapter1-01-exercise05.html">Chapter1 01 Exercise05</a></li>
          
        
      </ul>
    </aside>

    <footer>
        Hosted on <a href="http://github.com/">GitHub</a>, powered
        by <a href="http://jekyllrb.com">Jekyll</a>.
    </footer>
  </body>
</html>
