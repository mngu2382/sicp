<p>Title: Chapter 1: Exerices 1.16 -- 1.19 
Date: 2013-06-13
Slug: sicp/chapter1/part05
Category: SICP
Modified:
MathJax: True</p>

<h4>Exercise 1.16</h4>

<p>Design a procedure that evolves an iterative exponentiation process
that uses successive squaring and uses a logarithmic number of steps,
as does <code>fast-expt</code>. (Hint: Using the observation that
$(b^{n/2})^2 = (b^2)^{n/2}$, keep, along with the exponent $n$ and
the base $b$, an additional state variable $a$, and define that state
transformation in such a way that the product $ab^n$ is unchanged
from state to state. At the beginning of the process $a$ is taken to
be 1, and the answer is given by the value of $a$ at the end of the
process. In general, the technique of defining an <em>invariant
quantity</em> that remains unchanged from state to state is a powerful
way to think about the design of iterative algorithms.)</p>

<h5>Solution</h5>
<div class="highlight"><pre><code class="text language-text" data-lang="text">:::scheme
(define (fast-expt b n)
    (define (expt-iter a b n)
        (cond ((= n 0) a)
              ((even? n) (expt-iter a (square b) (/ n 2)))
              (else (expt-iter (* a b) b (- n 1)))))
    (expt-iter 1 b n))
</code></pre></div>
<h4>Exercise 1.17</h4>

<p>The exponentiation algorithms in this section are base on performing
exponentiation by means of repeated multiplication. In a similar way,
one can perform integer multiplication by means of repeated addition.
The following multiplication procedure (in which it is assumed that
our language can only add, not multiply) is analogous to the <code>expt</code>
procedure:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">:::scheme
(define (* a b)
    (if (= b 0)
        0
        (+ a (* a (- b 1)))))
</code></pre></div>
<p>This algorithm take a number of steps that is linear in <code>b</code>. Now
suppose we include, together with addition, operations <code>double</code>, which
doubles an integer, and <code>halve</code>, which divides an (even) integer by 2.
Using these, design a multiplication procedure analogous to
<code>fast-expt</code> that uses a logarithmic number of steps.</p>

<h5>Solution</h5>
<div class="highlight"><pre><code class="text language-text" data-lang="text">:::scheme
(define (fast-multiply a b)
    (if (&lt; (abs a) (abs b))
        (fast-multiply b a)
        (cond ((= 0 b) 0)
              ((even? b) (double (fast-multiply a (halve b))))
              (else (+ a (fast-multiply a (- b 1)))))))
</code></pre></div>
<h4>Exercise 1.18</h4>

<p>Using the results of Exercise 1.16 and Exercise 1.17, devise a
procedure that generates an iterative process for multiplying two
integers in terms of adding, doubling, and halving and uses a
logarithmic number of steps.</p>

<h5>Solution</h5>
<div class="highlight"><pre><code class="text language-text" data-lang="text">:::scheme
(define (fast-multiply a b)
    (define (multiply-iter x y acc)
        (cond ((= y 0) acc)
              ((even? y) (multiply-iter (double x) (halve y) acc))
              (else (multiply-iter x (- y 1) (+ acc x)))))
    (if (&lt; (abs a) (abs b))
        (multiply-iter b a 0)
        (multiply-iter a b 0)))
</code></pre></div>
<h4>Exercise 1.19</h4>

<p>There is a clever algorithm for computing the Fibonacci numbers in a
logarithmic number of steps. Recall the transformation of the state
$a$ and $b$ in the <code>fib-iter</code> process of of Section 1.2.2:</p>

<p>$$
\begin{align}
a&amp;\leftarrow a+b\\
b&amp;\leftarrow a.
\end{align}
$$</p>

<p>Call the transformation $T$, and observe that applying $T$ over and
over again $n$ times, starting with 1 and 0, produces the pair</p>

<p>$$
\begin{align}
&amp;\mathrm{Fib}(n+1)\\
&amp;\mathrm{Fib}(n).
\end{align}
$$</p>

<p>In other words, the Fibonacci numbers are produced by applying $T^n$,
the $n^{th}$ power of the transformation $T$, starting with the pair
$(1,0)$.</p>

<p>Now consider $T$ to be the special case of $p=0$ and $q=1$ in a family
of transformation $T<em>{pq}$, where $T</em>{pq}$ transforms the
pair $(a,b)$ according to</p>

<p>$$
\begin{align}
a&amp;\leftarrow bq+aq+ap\\
b&amp;\leftarrow bq+aq.
\end{align}
$$</p>

<p>Show that if we apply such a transformation $T<em>{pq}$ twice, the effect
is the same as using a single transformation $T</em>{p&#39;q&#39;}$ of the same
form, and compute $p&#39;$ and $q&#39;$ in terms of $p$ and $q$.</p>

<p>This gives us an explicit way to square these transformations, and
this we can compute $T^n$ using successive squaring, as in the
<code>fast-expt</code> procedure. Put this all together to complete the following,
which runs a logarithmic number of steps:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">:::scheme
(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   &lt;??&gt;       ; compute p&#39;
                   &lt;??&gt;       ; compute q&#39;
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
</code></pre></div>
<h5>Solution</h5>

<p>Applying $T<em>{pq}$ to $a</em>0,b_0$</p>

<p>$$
\begin{align}
a<em>1 &amp;= b</em>0q+a<em>0q+a</em>0p\\
b<em>1 &amp;= b</em>0p+a_0q
\end{align}
$$</p>

<p>Applying the transformation a second time to $a<em>0,b</em>0$</p>

<p>$$
\begin{align}
a<em>2 &amp;= b</em>1q+a<em>1q+a</em>1p\\
  &amp;= (b<em>0p+a</em>0q)q + ( b<em>0q+a</em>0q+a<em>0p)q + (b</em>0q+a<em>0q+a</em>0p)p\\
  &amp;= b<em>0(2pq+q^2) + a</em>0(2pq+q^2) + a<em>0(q^2+p^2)\\
b</em>2 &amp;= b<em>1p+a</em>1q\\
  &amp;= ( b<em>0p+a</em>0q)p + (b<em>0q+a</em>0q+a<em>0p)q\\
  &amp;= b</em>0(p^2+q^2) + a_0(2pq+q^2)
\end{align}
$$</p>

<p>Thus</p>

<p>$$
T<em>{pq}^2(a,b) = T</em>{p&#39;q&#39;}(a,b)
$$</p>

<p>where $p&#39;=p^2+q^2$ and $q&#39;=2pq+q^2$.</p>

<p>So completing the above code:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">:::scheme
(define (fib1 n)
  (fib-iter1 1 0 0 1 n))

(define (fib-iter1 a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter1 a
                   b
                   (+ (square p) (square q))
                   (+ (* 2 p q) (square q))
                   (/ count 2)))
        (else (fib-iter1 (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))
</code></pre></div>